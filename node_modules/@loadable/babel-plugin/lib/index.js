"use strict";

exports.__esModule = true;
exports.default = void 0;

var _pluginSyntaxDynamicImport = _interopRequireDefault(require("@babel/plugin-syntax-dynamic-import"));

var _chunkName = _interopRequireDefault(require("./properties/chunkName"));

var _isReady = _interopRequireDefault(require("./properties/isReady"));

var _requireAsync = _interopRequireDefault(require("./properties/requireAsync"));

var _requireSync = _interopRequireDefault(require("./properties/requireSync"));

var _resolve = _interopRequireDefault(require("./properties/resolve"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var properties = [_chunkName.default, _isReady.default, _requireAsync.default, _requireSync.default, _resolve.default];

var loadablePlugin = function loadablePlugin(api) {
  var t = api.types;

  function collectImportCallPaths(startPath) {
    var imports = [];
    startPath.traverse({
      Import: function Import(importPath) {
        imports.push(importPath.parentPath);
      }
    });
    return imports;
  }

  var propertyFactories = properties.map(function (init) {
    return init(api);
  });

  function isValidIdentifier(path) {
    // `loadable()`
    if (path.get('callee').isIdentifier({
      name: 'loadable'
    })) {
      return true;
    } // `loadable.lib()`


    return path.get('callee').isMemberExpression() && path.get('callee.object').isIdentifier({
      name: 'loadable'
    }) && path.get('callee.property').isIdentifier({
      name: 'lib'
    });
  }

  return {
    inherits: _pluginSyntaxDynamicImport.default,
    visitor: {
      CallExpression: function CallExpression(path) {
        if (!isValidIdentifier(path)) return;
        var callPaths = collectImportCallPaths(path); // Ignore loadable function that does not have any "import" call

        if (callPaths.length === 0) return; // Multiple imports call is not supported

        if (callPaths.length > 1) {
          throw new Error('loadable: multiple import calls inside `loadable()` function are not supported.');
        }

        var callPath = callPaths[0];
        var funcPath = path.get('arguments.0');
        funcPath.replaceWith(t.objectExpression(propertyFactories.map(function (getProperty) {
          return getProperty({
            path: path,
            callPath: callPath,
            funcPath: funcPath
          });
        })));
      }
    }
  };
};

var _default = loadablePlugin;
exports.default = _default;